extern crate capnpc;

use std::fs::{File, create_dir_all};
use std::io::{self, Write};
use std::path::Path;

fn main() -> io::Result<()> {
    println!("cargo:rerun-if-changed=cereal/");
    println!("cargo:rerun-if-changed=src/cereal");
    let src_prefix = "cereal";
    let capnp_files = ["log.capnp", "car.capnp", "custom.capnp", "legacy.capnp", "maptile.capnp"];
    let out_dir = Path::new("src/cereal");


    // Ensure the output directory exists
    create_dir_all(&out_dir)?;

    // Create CompilerCommand using a loop to add all files
    let mut command = capnpc::CompilerCommand::new();
    command.src_prefix(&src_prefix).output_path(&out_dir);
    for file in &capnp_files {
        let file_path = format!("{}/{}", &src_prefix, file);
        if !Path::new(&file_path).exists() {
            eprintln!("Error: File not found: {}", file_path);
            return Err(io::Error::new(io::ErrorKind::NotFound, format!("File not found: {}", file_path)));
        }
        command.file(file_path);
    }
    command.default_parent_module(vec!["cereal".into()]);
    command.run(); // Propagate errors using `?`

    // Create or truncate the mod.rs file
    let mod_rs_path = out_dir.join("mod.rs");
    let mut mod_rs_file = File::create(&mod_rs_path)?;

    // Write the generated file notice
    writeln!(mod_rs_file, "// This file is generated by build.rs")?;
    for file in &capnp_files {
        let module_name = file.strip_suffix(".capnp").unwrap_or(file);
        writeln!(mod_rs_file, "pub mod {}_capnp;", module_name)?;
    }

    Ok(())
}